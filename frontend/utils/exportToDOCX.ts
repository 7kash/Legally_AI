/**
 * DOCX Export Utility
 * Export analysis results to Microsoft Word format
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle } from 'docx'
import { saveAs } from 'file-saver'

export interface DOCXExportOptions {
  title: string
  content: Record<string, any>
  metadata?: {
    contractName?: string
    analysisDate?: string
    confidenceScore?: number
  }
}

/**
 * Export analysis to professionally formatted DOCX
 */
export async function exportAnalysisToDOCX(options: DOCXExportOptions): Promise<void> {
  const { title, content, metadata } = options

  const documentChildren: Paragraph[] = []

  // Title
  documentChildren.push(
    new Paragraph({
      text: title,
      heading: HeadingLevel.HEADING_1,
      spacing: { after: 400 },
    })
  )

  // Metadata section
  if (metadata) {
    if (metadata.contractName) {
      documentChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Contract: ',
              bold: true,
            }),
            new TextRun(metadata.contractName),
          ],
          spacing: { after: 200 },
        })
      )
    }

    if (metadata.analysisDate) {
      documentChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Analysis Date: ',
              bold: true,
            }),
            new TextRun(metadata.analysisDate),
          ],
          spacing: { after: 200 },
        })
      )
    }

    if (metadata.confidenceScore !== undefined) {
      const scorePercent = Math.round(metadata.confidenceScore * 100)
      documentChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Confidence Score: ',
              bold: true,
            }),
            new TextRun({
              text: `${scorePercent}%`,
              bold: true,
              color: scorePercent >= 80 ? '22C55E' : scorePercent >= 60 ? 'EAB308' : 'EF4444',
            }),
          ],
          spacing: { after: 400 },
        })
      )
    }
  }

  // Disclaimer
  documentChildren.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'IMPORTANT: This is an AI-powered informational screening — not legal advice.',
          italics: true,
          color: '92400E',
        }),
      ],
      spacing: { after: 400 },
      border: {
        top: { style: BorderStyle.SINGLE, size: 1, color: 'FDE68A' },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: 'FDE68A' },
        left: { style: BorderStyle.SINGLE, size: 1, color: 'FDE68A' },
        right: { style: BorderStyle.SINGLE, size: 1, color: 'FDE68A' },
      },
      shading: {
        fill: 'FEF3C7',
      },
    })
  )

  // Content sections
  for (const [key, value] of Object.entries(content)) {
    const sectionTitle = formatSectionTitle(key)

    // Section heading
    documentChildren.push(
      new Paragraph({
        text: sectionTitle,
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 },
        shading: {
          fill: 'E5E7EB',
        },
      })
    )

    // Section content
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        const paragraphs = formatArrayItem(item, index + 1)
        documentChildren.push(...paragraphs)
      })
    } else if (typeof value === 'object' && value !== null) {
      for (const [subKey, subValue] of Object.entries(value)) {
        const formattedKey = formatKey(subKey)

        documentChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${formattedKey}: `,
                bold: true,
                color: '4B5563',
              }),
              new TextRun({
                text: formatObjectValue(subValue),
                color: '6B7280',
              }),
            ],
            spacing: { after: 200 },
          })
        )
      }
    } else {
      documentChildren.push(
        new Paragraph({
          text: String(value),
          spacing: { after: 200 },
        })
      )
    }
  }

  // Footer
  const timestamp = new Date().toLocaleString()
  documentChildren.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by Legally AI on ${timestamp}`,
          size: 16,
          color: '9CA3AF',
        }),
      ],
      spacing: { before: 600 },
      alignment: AlignmentType.CENTER,
    })
  )

  // Create document
  const doc = new Document({
    sections: [
      {
        properties: {},
        children: documentChildren,
      },
    ],
  })

  // Generate and save
  const blob = await Packer.toBlob(doc)
  const filename = `${sanitizeFilename(metadata?.contractName || title)}_analysis.docx`
  saveAs(blob, filename)
}

/**
 * Format array items for DOCX
 */
function formatArrayItem(item: any, index: number): Paragraph[] {
  const paragraphs: Paragraph[] = []

  if (typeof item === 'string') {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `${index}. `,
            bold: true,
          }),
          new TextRun(item),
        ],
        spacing: { after: 150 },
        bullet: {
          level: 0,
        },
      })
    )
    return paragraphs
  }

  if (typeof item === 'object' && item !== null) {
    // Handle obligation objects
    if ('action' in item) {
      const children: TextRun[] = [
        new TextRun({
          text: `${index}. ${item.action}`,
          bold: true,
        }),
      ]

      if (item.time_window) {
        children.push(new TextRun({ text: '\n' }))
        children.push(new TextRun({ text: `When: ${item.time_window}`, italics: true }))
      }

      if (item.trigger) {
        children.push(new TextRun({ text: '\n' }))
        children.push(new TextRun({ text: `Trigger: ${item.trigger}`, italics: true }))
      }

      if (item.consequence) {
        children.push(new TextRun({ text: '\n' }))
        children.push(new TextRun({ text: `If not done: ${item.consequence}`, color: 'DC2626' }))
      }

      paragraphs.push(
        new Paragraph({
          children,
          spacing: { after: 200 },
          bullet: {
            level: 0,
          },
        })
      )
      return paragraphs
    }

    // Handle right objects
    if ('right' in item) {
      const children: TextRun[] = [
        new TextRun({
          text: `${index}. ${item.right}`,
          bold: true,
        }),
      ]

      if (item.how_to_exercise) {
        children.push(new TextRun({ text: '\n' }))
        children.push(new TextRun({ text: `How: ${item.how_to_exercise}`, italics: true }))
      }

      if (item.conditions) {
        children.push(new TextRun({ text: '\n' }))
        children.push(new TextRun({ text: `Conditions: ${item.conditions}`, italics: true }))
      }

      paragraphs.push(
        new Paragraph({
          children,
          spacing: { after: 200 },
          bullet: {
            level: 0,
          },
        })
      )
      return paragraphs
    }

    // Handle risk objects
    if ('description' in item && 'level' in item) {
      const levelColor = item.level === 'high' ? 'DC2626' : item.level === 'medium' ? 'EAB308' : '22C55E'

      const children: TextRun[] = [
        new TextRun({
          text: `[${item.level.toUpperCase()}] `,
          bold: true,
          color: levelColor,
        }),
        new TextRun(item.description),
      ]

      if (item.recommendation) {
        children.push(new TextRun({ text: '\n' }))
        children.push(
          new TextRun({
            text: `→ ${item.recommendation}`,
            color: '2563EB',
            italics: true,
          })
        )
      }

      paragraphs.push(
        new Paragraph({
          children,
          spacing: { after: 200 },
          bullet: {
            level: 0,
          },
        })
      )
      return paragraphs
    }

    // Handle party objects
    if ('name' in item && 'role' in item) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${index}. ${item.name}`,
              bold: true,
            }),
            new TextRun({ text: '\n' }),
            new TextRun({
              text: `Role: ${item.role}`,
              italics: true,
            }),
          ],
          spacing: { after: 200 },
          bullet: {
            level: 0,
          },
        })
      )
      return paragraphs
    }

    // Generic object
    const objectText = Object.entries(item)
      .map(([k, v]) => `${formatKey(k)}: ${v}`)
      .join(', ')

    paragraphs.push(
      new Paragraph({
        text: `${index}. ${objectText}`,
        spacing: { after: 150 },
        bullet: {
          level: 0,
        },
      })
    )
    return paragraphs
  }

  paragraphs.push(
    new Paragraph({
      text: `${index}. ${String(item)}`,
      spacing: { after: 150 },
      bullet: {
        level: 0,
      },
    })
  )
  return paragraphs
}

/**
 * Format object values for DOCX
 */
function formatObjectValue(value: any): string {
  if (Array.isArray(value)) {
    return value.map((v, i) => {
      if (typeof v === 'string') return `${i + 1}. ${v}`
      if (typeof v === 'object' && v !== null) {
        if ('action' in v) return `${i + 1}. ${v.action}`
        if ('right' in v) return `${i + 1}. ${v.right}`
        if ('description' in v) return `${i + 1}. ${v.description}`
        return `${i + 1}. ${JSON.stringify(v)}`
      }
      return `${i + 1}. ${String(v)}`
    }).join('; ')
  }

  if (typeof value === 'object' && value !== null) {
    return Object.entries(value)
      .map(([k, v]) => `${formatKey(k)}: ${v}`)
      .join(', ')
  }

  return String(value)
}

function formatSectionTitle(key: string): string {
  return key
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

function formatKey(key: string | number): string {
  if (typeof key === 'number') return `${key + 1}`

  return String(key)
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}

function sanitizeFilename(filename: string): string {
  return filename
    .replace(/[^a-z0-9]/gi, '_')
    .replace(/_+/g, '_')
    .toLowerCase()
}
